# backend/main.py
from __future__ import annotations

import sys
import os

# --- START: FIX PYTHON PATH ---
# This block ensures that the correct directory is added to the Python path.
# This allows imports like 'from modules.ml...' to work correctly
# regardless of how the script is executed.

# Get the absolute path of the directory containing this file (backend/)
backend_dir = os.path.dirname(os.path.abspath(__file__))

# Add the backend directory to the system path if it's not already there
# This allows imports like 'from modules.ml...' to work
if backend_dir not in sys.path:
    sys.path.insert(0, backend_dir)
    print(f"‚úÖ Added backend directory to Python path: {backend_dir}")
else:
    print(f"‚úÖ Backend directory already in Python path: {backend_dir}")

# Also add the project root (parent of backend) for absolute imports like 'from backend.modules...'
project_root = os.path.dirname(backend_dir)
if project_root not in sys.path:
    sys.path.insert(0, project_root)
    print(f"‚úÖ Added project root to Python path: {project_root}")
else:
    print(f"‚úÖ Project root already in Python path: {project_root}")
# --- END: FIX PYTHON PATH ---

import logging
import importlib
from contextlib import asynccontextmanager
from typing import Optional, List, Dict, Any

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

# ---------------------- optional DB (graceful) ----------------------
try:
    from .db import engine, Base  # type: ignore
except Exception:  # pragma: no cover
    engine = None  # type: ignore
    Base = None  # type: ignore


def _include_optional_router(app: FastAPI, modname: str, tag: str, prefix: str = "/api") -> None:
    """
    Best-effort import and mount of a router module at .routes.<modname>.
    Skips cleanly (with a log) if the module or router is missing.
    """
    try:
        print(f"üîç Attempting to mount router: {modname}")
        
        # Try absolute import first (when running from project root)
        try:
            mod = importlib.import_module(f"routes.{modname}")
            print(f"‚úÖ Absolute import successful for {modname}")
        except ImportError:
            # Fallback to relative import (when running from backend directory)
            try:
                if __package__:
                    mod = importlib.import_module(f".routes.{modname}", package=__package__)
                    print(f"‚úÖ Relative import successful for {modname}")
                else:
                    # When running directly, try to import as if we're in the backend package
                    mod = importlib.import_module(f"routes.{modname}")
                    print(f"‚úÖ Direct import successful for {modname}")
            except ImportError:
                print(f"‚ùå Both absolute and relative imports failed for {modname}")
                raise
        
        router = getattr(mod, "router", None)
        if router is None:
            print(f"‚ùå Router module '{modname}' has no 'router' attribute; skipping.")
            logging.warning(f"Router module '{modname}' has no 'router' attribute; skipping.")
            return
        print(f"‚úÖ Router found for {modname}: {router}")
        print(f"üîç Router routes before mounting: {[route.path for route in router.routes]}")
        print(f"üîç Router route count before mounting: {len(router.routes)}")
        app.include_router(router, prefix=prefix, tags=[tag])
        print(f"‚úÖ Mounted router: {modname} at {prefix} (tag: {tag})")
        print(f"üîç Router routes after mounting: {[route.path for route in router.routes]}")
        print(f"üîç Router route count after mounting: {len(router.routes)}")
        logging.info(f"Mounted router: {modname} at {prefix} (tag: {tag})")
    except Exception as e:
        print(f"‚ùå Router '{modname}' not mounted: {e}")
        logging.warning(f"Router '{modname}' not mounted ({e}).")


def _env_true(name: str, default: bool = False) -> bool:
    v = str(os.getenv(name, "")).strip().lower()
    if v in ("1", "true", "yes", "on"):
        return True
    if v in ("0", "false", "no", "off"):
        return False
    return default


@asynccontextmanager
async def lifespan(app: FastAPI):
    # Optional dev-time auto-create of DB tables
    if os.getenv("DEV_CREATE_ALL") == "1":
        if Base is not None and engine is not None:
            try:
                Base.metadata.create_all(bind=engine)  # type: ignore[attr-defined]
                logging.info("DB initialized / verified (DEV_CREATE_ALL=1).")
            except Exception:
                logging.exception("DB init failed.")
        else:
            logging.info("DB not configured; skipping create_all (DEV_CREATE_ALL=1).")
    yield


# ----------------------------- app -----------------------------

# Honor LOG_LEVEL if present; otherwise auto-enable DEBUG when ELISE_ML_DEBUG=1
_DEFAULT_LEVEL = "DEBUG" if _env_true("ELISE_ML_DEBUG", False) else "INFO"
_LOG_LEVEL = os.getenv("LOG_LEVEL", _DEFAULT_LEVEL)
logging.basicConfig(level=_LOG_LEVEL)
logging.info("Starting API (LOG_LEVEL=%s, ELISE_ML_DEBUG=%s, ELISE_ML_MODEL_DIR=%s)",
             _LOG_LEVEL, _env_true("ELISE_ML_DEBUG", False), os.getenv("ELISE_ML_MODEL_DIR") or "-")

app = FastAPI(
    title="Automated Web Vulnerability Assessment API",
    description=(
        "Proxy-based crawling, fuzzing, active scanning, and ML-driven payload recommendation."
    ),
    version="1.0.0",
    lifespan=lifespan,
)

# Permissive CORS for dev; tighten before shipping to prod
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # TODO: restrict in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# ------------------------- mount routers -------------------------
# Each is optional; absence won't crash the app.
_include_optional_router(app, "crawl_routes", "Crawl")
_include_optional_router(app, "category_routes", "Categorization")
_include_optional_router(app, "probe_routes", "Probe")
_include_optional_router(app, "recommend_routes", "Recommender")  # exposes /api/recommend_payloads and /api/diagnostics/ltr
_include_optional_router(app, "job_routes", "Job")
_include_optional_router(app, "fuzz_routes", "Fuzzing")
_include_optional_router(app, "evidence_routes", "Evidence")
_include_optional_router(app, "verify_routes", "Verify")
_include_optional_router(app, "report_routes", "Report")
_include_optional_router(app, "ml_routes", "ML")

# Mount the enhanced ML fuzzer router
_include_optional_router(app, "enhanced_fuzz_routes", "Enhanced ML Fuzzing")

# Mount the enhanced crawl router
_include_optional_router(app, "enhanced_crawl_routes", "Enhanced Crawl")

# Enhanced ML endpoints are also added directly to the main app

# ------------------------- Enhanced ML Fuzzing Endpoints -------------------------
@app.post("/api/enhanced-fuzz")
async def enhanced_fuzz_direct(targets: List[Dict[str, Any]], top_k: int = 5):
    """
    Enhanced ML fuzzing endpoint that directly uses enhanced ML for:
    - Stage A: Family prediction (SQLi, XSS, Redirect, etc.)
    - Stage B: Payload recommendation with confidence scores
    """
    try:
        # Import enhanced ML directly
        from modules.ml.enhanced_inference import EnhancedInferenceEngine
        from modules.family_router import payload_pool_for
        
        enhanced_engine = EnhancedInferenceEngine()
        print("‚úÖ Enhanced ML Fuzzer: Engine initialized successfully")
        
        results = []
        
        for target in targets:
            try:
                print(f"üöÄ Enhanced ML Fuzzer: Processing {target['url']} param={target['param']}")
                
                # Stage A: Family prediction using enhanced ML
                family_proba = enhanced_engine.predict_family_proba(target['url'], target['param'], target.get('method', 'GET'))
                
                if family_proba and len(family_proba) > 0:
                    # Get the family with highest probability
                    best_family = max(family_proba, key=lambda x: x.get("probability", 0))
                    family = best_family.get("family", "xss")
                    family_confidence = best_family.get("probability", 0.0)
                    print(f"‚úÖ Enhanced ML Fuzzer: Family prediction: {family} (confidence: {family_confidence:.4f})")
                else:
                    family = "xss"  # Default fallback
                    family_confidence = 0.0
                    print("‚ö†Ô∏è Enhanced ML Fuzzer: No family prediction, defaulting to XSS")
                
                # Stage B: Payload recommendation using enhanced ML
                payload_pool = payload_pool_for(family)
                if not payload_pool:
                    print(f"‚ö†Ô∏è Enhanced ML Fuzzer: No payload pool for family {family}")
                    continue
                
                # Create endpoint and param info for enhanced ML
                endpoint_info = {
                    "url": target['url'],
                    "method": target.get('method', 'GET'),
                    "content_type": "application/x-www-form-urlencoded"
                }
                param_info = {
                    "name": target['param'],
                    "value": "",
                    "loc": "query"
                }
                
                # Get enhanced ML payload ranking
                ranked_payloads = enhanced_engine.rank_payloads(
                    endpoint_info, 
                    param_info, 
                    family, 
                    payload_pool, 
                    top_k=3
                )
                
                if ranked_payloads:
                    print(f"‚úÖ Enhanced ML Fuzzer: Got {len(ranked_payloads)} ranked payloads for {family}")
                    
                    for payload_info in ranked_payloads:
                        payload = payload_info["payload"]
                        ml_score = payload_info.get("score", 0.0)
                        ml_confidence = payload_info.get("confidence", 0.0)
                        ml_uncertainty = payload_info.get("uncertainty", 0.0)
                        
                        print(f"üß™ Enhanced ML Fuzzer: Testing payload: {payload[:50]}... (score: {ml_score:.4f})")
                        
                        # Create enhanced ML result
                        result = {
                            "url": target['url'],
                            "param": target['param'],
                            "method": target.get('method', 'GET'),
                            "payload": payload,
                            "confidence": float(ml_score),
                            "status": "ok",
                            "family": family,
                            "origin": "enhanced_ml",
                            "ranker_meta": {
                                "used_path": "enhanced_ml",
                                "family": family,
                                "enhanced": True,
                                "confidence": ml_confidence,
                                "uncertainty": ml_uncertainty,
                                "ml_score": ml_score,
                                "family_confidence": family_confidence,
                                "model_ids": {"ranker_path": f"enhanced_{family}_xgboost", "enhanced_ml": True}
                            },
                            "ranker_score": float(ml_score),
                            "ml": {
                                "enabled": True,
                                "enhanced": True,
                                "p": ml_confidence,  # Calibrated probability
                                "confidence": ml_confidence,
                                "uncertainty": ml_uncertainty,
                                "family": family,
                                "family_confidence": family_confidence
                            },
                            "signals": {},
                            "payload_id": "enhanced_ml",
                            "verify": None,
                            "baseline": None,
                            "delta": None
                        }
                        results.append(result)
                        print(f"‚úÖ Enhanced ML Fuzzer: Added result for payload: {payload[:30]}...")
                else:
                    print(f"‚ö†Ô∏è Enhanced ML Fuzzer: No payloads ranked for {family}")
                    
            except Exception as e:
                print(f"‚ùå Enhanced ML Fuzzer: Failed to process target {target['url']}: {e}")
                # Add error result
                error_result = {
                    "url": target['url'],
                    "param": target['param'],
                    "method": target.get('method', 'GET'),
                    "payload": "",
                    "confidence": 0.0,
                    "status": "error",
                    "error": str(e),
                    "family": "unknown",
                    "origin": "enhanced_ml_failed",
                    "ranker_meta": {"used_path": "enhanced_ml_failed", "error": str(e)},
                    "ranker_score": None,
                    "ml": False,
                    "signals": {},
                    "payload_id": "enhanced_ml_failed"
                }
                results.append(error_result)
        
        print(f"üéâ Enhanced ML Fuzzer: Completed with {len(results)} results")
        
        return {"results": results}
        
    except Exception as e:
        print(f"‚ùå Enhanced ML Fuzzer: Critical failure: {e}")
        # Add critical error result
        for target in targets:
            error_result = {
                "url": target['url'],
                "param": target['param'],
                "method": target.get('method', 'GET'),
                "payload": "",
                "confidence": 0.0,
                "status": "error",
                "error": f"Enhanced ML Engine failed: {e}",
                "family": "unknown",
                "origin": "enhanced_ml_critical_failure",
                "ranker_meta": {"used_path": "enhanced_ml_critical_failure", "error": str(e)},
                "ranker_score": None,
                "ml": False,
                "signals": {},
                "payload_id": "enhanced_ml_critical_failure"
            }
            results.append(error_result)
        
        return {"results": results}

@app.get("/api/enhanced-fuzz/health")
async def enhanced_fuzz_health():
    """Health check for enhanced ML fuzzer"""
    try:
        from modules.ml.enhanced_inference import EnhancedInferenceEngine
        enhanced_engine = EnhancedInferenceEngine()
        return {
            "status": "healthy",
            "enhanced_ml_fuzzer": True,
            "enhanced_ml_engine": True,
            "family_prediction": True,
            "payload_recommendation": True,
            "message": "Enhanced ML Fuzzer is ready"
        }
    except Exception as e:
        return {
            "status": "unhealthy",
            "enhanced_ml_fuzzer": False,
            "error": str(e),
            "message": "Enhanced ML Fuzzer is not ready"
        }

@app.get("/api/enhanced-fuzz/info")
async def enhanced_fuzz_info():
    """Get information about the enhanced ML fuzzer"""
    try:
        from modules.ml.enhanced_inference import EnhancedInferenceEngine
        enhanced_engine = EnhancedInferenceEngine()
        return {
            "name": "Enhanced ML Fuzzer",
            "description": "Brand new fuzzer that directly uses enhanced ML for family prediction and payload recommendation",
            "version": "1.0.0",
            "features": [
                "Stage A: Family prediction (SQLi, XSS, Redirect, etc.)",
                "Stage B: Payload recommendation with confidence scores",
                "Direct enhanced ML integration",
                "No heuristic fallbacks",
                "Clean, simplified architecture"
            ],
            "enhanced_ml": True,
            "family_prediction": True,
            "payload_recommendation": True,
            "status": "ready"
        }
    except Exception as e:
        return {
            "name": "Enhanced ML Fuzzer",
            "description": "Brand new fuzzer that directly uses enhanced ML",
            "status": "error",
            "error": str(e)
        }

@app.post("/api/enhanced-fuzz/crawl-and-fuzz")
async def enhanced_fuzz_crawl_and_fuzz(request: Dict[str, Any]):
    """
    Simple crawl and fuzz endpoint that discovers endpoints and tests them with enhanced ML
    """
    try:
        target_url = request.get("target_url", "http://localhost:8082/")
        max_pages = request.get("max_pages", 10)
        
        print(f"üöÄ Enhanced ML: Crawling {target_url} for up to {max_pages} pages")
        
        # Simple endpoint discovery (no complex crawling)
        test_endpoints = [
            {"url": f"{target_url}?q=test", "param": "q", "method": "GET"},
            {"url": f"{target_url}search?query=test", "param": "query", "method": "GET"},
            {"url": f"{target_url}api/test?input=test", "param": "input", "method": "GET"},
            {"url": f"{target_url}form?name=test", "param": "name", "method": "POST"},
            {"url": f"{target_url}admin?user=test", "param": "user", "method": "GET"},
        ]
        
        print(f"‚úÖ Enhanced ML: Testing {len(test_endpoints)} discovered endpoints")
        
        # Use the enhanced ML fuzzer
        from modules.ml.enhanced_inference import EnhancedInferenceEngine
        from modules.family_router import payload_pool_for
        
        enhanced_engine = EnhancedInferenceEngine()
        results = []
        
        for endpoint in test_endpoints:
            try:
                print(f"üß™ Enhanced ML: Testing {endpoint['url']} param={endpoint['param']}")
                
                # Stage A: Family prediction
                family_proba = enhanced_engine.predict_family_proba(
                    endpoint['url'], 
                    endpoint['param'], 
                    endpoint['method']
                )
                
                if family_proba and len(family_proba) > 0:
                    best_family = max(family_proba, key=lambda x: x.get("probability", 0))
                    family = best_family.get("family", "xss")
                    family_confidence = best_family.get("probability", 0.0)
                    print(f"‚úÖ Enhanced ML: Family prediction: {family} (confidence: {family_confidence:.4f})")
                else:
                    family = "xss"
                    family_confidence = 0.0
                
                # Stage B: Payload recommendation
                payload_pool = payload_pool_for(family)
                if payload_pool:
                    endpoint_info = {
                        "url": endpoint['url'],
                        "method": endpoint['method'],
                        "content_type": "application/x-www-form-urlencoded"
                    }
                    param_info = {
                        "name": endpoint['param'],
                        "value": "",
                        "loc": "query"
                    }
                    
                    ranked_payloads = enhanced_engine.rank_payloads(
                        endpoint_info, 
                        param_info, 
                        family, 
                        payload_pool, 
                        top_k=2
                    )
                    
                    if ranked_payloads:
                        for payload_info in ranked_payloads[:2]:  # Top 2 payloads
                            payload = payload_info["payload"]
                            ml_score = payload_info.get("score", 0.0)
                            
                            result = {
                                "url": endpoint['url'],
                                "param": endpoint['param'],
                                "method": endpoint['method'],
                                "payload": payload,
                                "confidence": float(ml_score),
                                "status": "ok",
                                "family": family,
                                "origin": "enhanced_ml_crawl",
                                "ranker_meta": {
                                    "used_path": "enhanced_ml_crawl",
                                    "family": family,
                                    "enhanced": True,
                                    "ml_score": ml_score,
                                    "family_confidence": family_confidence
                                },
                                "ranker_score": float(ml_score),
                                "ml": {
                                    "enabled": True,
                                    "enhanced": True,
                                    "family": family,
                                    "family_confidence": family_confidence
                                }
                            }
                            results.append(result)
                            print(f"‚úÖ Enhanced ML: Added result for {payload[:30]}...")
                
            except Exception as e:
                print(f"‚ùå Enhanced ML: Failed to process {endpoint['url']}: {e}")
        
        print(f"üéâ Enhanced ML: Crawl and fuzz completed with {len(results)} results")
        return {
            "status": "success",
            "message": f"Enhanced ML crawl and fuzz completed for {target_url}",
            "target_url": target_url,
            "results": results,
            "enhanced_ml": True
        }
        
    except Exception as e:
        print(f"‚ùå Enhanced ML: Crawl and fuzz failed: {e}")
        return {
            "status": "error",
            "message": f"Enhanced ML crawl and fuzz failed: {e}",
            "enhanced_ml": False
        }

@app.post("/api/enhanced-crawl")
async def enhanced_crawl_simple(request: Dict[str, Any]):
    """
    Simple enhanced crawl endpoint that discovers endpoints for fuzzing
    """
    try:
        target_url = request.get("target_url", "http://localhost:8082/")
        max_endpoints = request.get("max_endpoints", 20)
        
        print(f"üöÄ Enhanced Crawl: Discovering endpoints for {target_url}")
        
        # Simple endpoint discovery (same logic as the router)
        discovered_endpoints = []
        
        # Common endpoint patterns
        patterns = [
            {"path": "search", "param": "q", "method": "GET"},
            {"path": "search", "param": "query", "method": "GET"},
            {"path": "api/search", "param": "query", "method": "GET"},
            {"path": "admin", "param": "user", "method": "GET"},
            {"path": "profile", "param": "id", "method": "GET"},
            {"path": "products", "param": "category", "method": "GET"},
            {"path": "contact", "param": "message", "method": "POST"},
        ]
        
        # Generate endpoints
        for pattern in patterns:
            endpoint = {
                "url": f"{target_url.rstrip('/')}/{pattern['path']}",
                "param": pattern["param"],
                "method": pattern["method"],
                "path": pattern["path"],
                "type": "discovered"
            }
            discovered_endpoints.append(endpoint)
        
        # Add root-level parameters
        common_params = ["id", "name", "email", "search", "query", "filter"]
        for param in common_params:
            endpoint = {
                "url": f"{target_url}?{param}=test",
                "param": param,
                "method": "GET",
                "path": "/",
                "type": "dynamic"
            }
            discovered_endpoints.append(endpoint)
        
        # Limit endpoints
        if len(discovered_endpoints) > max_endpoints:
            discovered_endpoints = discovered_endpoints[:max_endpoints]
        
        print(f"‚úÖ Enhanced Crawl: Discovered {len(discovered_endpoints)} endpoints")
        
        return {
            "status": "success",
            "message": f"Enhanced crawl completed for {target_url}",
            "target_url": target_url,
            "discovered_endpoints": len(discovered_endpoints),
            "endpoints": discovered_endpoints,
            "enhanced_ml": True,
            "ready_for_fuzzing": True
        }
        
    except Exception as e:
        print(f"‚ùå Enhanced Crawl failed: {e}")
        return {
            "status": "error",
            "message": f"Enhanced crawl failed: {e}",
            "enhanced_ml": False
        }

# ------------------------- health & root -------------------------

@app.get("/")
def root():
    return {"message": "Welcome to the Automated Vulnerability Assessment API"}

@app.get("/health")
def health():
    return {
        "status": "ok",
        "log_level": _LOG_LEVEL,
        "ml_debug": _env_true("ELISE_ML_DEBUG", False),
        "model_dir": os.getenv("ELISE_MODEL_DIR") or os.getenv("MODEL_DIR") or os.getenv("ELISE_MODEL_DIR") or None,
    }

# ------------------------- server startup -------------------------

if __name__ == "__main__":
    import uvicorn
    
    print("üöÄ Starting Enhanced ML Fuzzer Backend Server...")
    print("üì° Server will be available at: http://localhost:8000")
    print("üìö API Documentation: http://localhost:8000/docs")
    print("üîç Enhanced ML Endpoints:")
    print("   - POST /api/enhanced-fuzz")
    print("   - GET  /api/enhanced-fuzz/health")
    print("   - GET  /api/enhanced-fuzz/info")
    print("   - POST /api/fuzz/single")
    print("   - GET  /api/enhanced-health")
    print("   - GET  /api/enhanced-info")
    
    uvicorn.run(
        "main:app",
        host="0.0.0.0",
        port=8000,
        reload=True,
        log_level=_LOG_LEVEL.lower()
    )
