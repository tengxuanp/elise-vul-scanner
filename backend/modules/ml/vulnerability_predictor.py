"""
Real ML-based Vulnerability Type Predictor
Predicts vulnerability types (XSS, SQLi, etc.) based on endpoint characteristics
"""

import numpy as np
import pandas as pd
from sklearn.ensemble import RandomForestClassifier
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, accuracy_score
import joblib
import logging
from typing import List, Dict, Any, Tuple
from pathlib import Path

logger = logging.getLogger(__name__)

class VulnerabilityPredictor:
    """Real ML model to predict vulnerability types from endpoint features"""
    
    def __init__(self, model_path: str = "models/vulnerability_predictor.joblib"):
        self.model_path = Path(model_path)
        self.model = None
        self.vectorizer = None
        self.vulnerability_types = ["xss", "sqli", "rce", "lfi", "redirect", "none"]
        self.feature_names = []
        
    def extract_features(self, endpoint: Dict[str, Any]) -> np.ndarray:
        """Extract features from endpoint for ML prediction"""
        features = []
        
        # URL-based features
        url = endpoint.get("url", "")
        path = endpoint.get("path", "")
        param = endpoint.get("param", "")
        method = endpoint.get("method", "GET")
        
        # 1. URL length
        features.append(len(url))
        
        # 2. Path depth (number of slashes)
        features.append(path.count("/"))
        
        # 3. Parameter name features
        param_features = [
            1 if "id" in param.lower() else 0,
            1 if "search" in param.lower() or "q" in param.lower() else 0,
            1 if "email" in param.lower() else 0,
            1 if "user" in param.lower() else 0,
            1 if "admin" in param.lower() else 0,
            1 if "file" in param.lower() else 0,
        ]
        features.extend(param_features)
        
        # 4. HTTP method features
        method_features = [
            1 if method == "GET" else 0,
            1 if method == "POST" else 0,
            1 if method == "PUT" else 0,
            1 if method == "DELETE" else 0,
        ]
        features.extend(method_features)
        
        # 5. Path-based features
        path_features = [
            1 if "api" in path.lower() else 0,
            1 if "rest" in path.lower() else 0,
            1 if "search" in path.lower() else 0,
            1 if "login" in path.lower() else 0,
            1 if "admin" in path.lower() else 0,
            1 if "upload" in path.lower() else 0,
            1 if "user" in path.lower() else 0,
            1 if "product" in path.lower() else 0,
        ]
        features.extend(path_features)
        
        # 6. Content type features (if available)
        content_type = endpoint.get("content_type", "")
        content_features = [
            1 if "json" in content_type.lower() else 0,
            1 if "html" in content_type.lower() else 0,
            1 if "text" in content_type.lower() else 0,
        ]
        features.extend(content_features)
        
        # 7. Response status features
        status = endpoint.get("status", 200)
        status_features = [
            1 if status == 200 else 0,
            1 if status == 401 else 0,
            1 if status == 403 else 0,
            1 if status == 404 else 0,
            1 if status == 500 else 0,
        ]
        features.extend(status_features)
        
        return np.array(features)
    
    def train(self, training_data: List[Dict[str, Any]]) -> Dict[str, float]:
        """Train the ML model on endpoint data"""
        logger.info(f"üöÄ Training vulnerability predictor with {len(training_data)} samples")
        
        # Prepare training data
        X = []
        y = []
        
        for sample in training_data:
            features = self.extract_features(sample)
            X.append(features)
            y.append(sample.get("vulnerability_type", "none"))
        
        X = np.array(X)
        y = np.array(y)
        
        # Split data
        X_train, X_test, y_train, y_test = train_test_split(
            X, y, test_size=0.2, random_state=42, stratify=y
        )
        
        # Train model
        self.model = RandomForestClassifier(
            n_estimators=100,
            max_depth=10,
            random_state=42,
            class_weight="balanced"
        )
        
        self.model.fit(X_train, y_train)
        
        # Evaluate
        y_pred = self.model.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        
        logger.info(f"‚úÖ Model trained with accuracy: {accuracy:.3f}")
        logger.info(f"üìä Classification Report:\n{classification_report(y_test, y_pred)}")
        
        # Save model
        self.model_path.parent.mkdir(parents=True, exist_ok=True)
        joblib.dump(self.model, self.model_path)
        
        return {
            "accuracy": accuracy,
            "training_samples": len(training_data),
            "test_samples": len(X_test)
        }
    
    def predict(self, endpoints: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        """Predict vulnerability types for endpoints"""
        if self.model is None:
            self.load_model()
        
        predictions = []
        
        for endpoint in endpoints:
            features = self.extract_features(endpoint)
            features = features.reshape(1, -1)
            
            # Get prediction probabilities
            probabilities = self.model.predict_proba(features)[0]
            
            # Get class labels
            classes = self.model.classes_
            
            # Create prediction result
            prediction = {
                "endpoint": endpoint,
                "predicted_type": self.model.predict(features)[0],
                "confidence": float(max(probabilities)),
                "probabilities": {
                    classes[i]: float(probabilities[i]) 
                    for i in range(len(classes))
                }
            }
            
            predictions.append(prediction)
        
        return predictions
    
    def load_model(self) -> bool:
        """Load trained model from disk"""
        try:
            if self.model_path.exists():
                self.model = joblib.load(self.model_path)
                logger.info("‚úÖ Loaded vulnerability predictor model")
                return True
            else:
                logger.warning("‚ö†Ô∏è No trained model found, using default predictions")
                return False
        except Exception as e:
            logger.error(f"‚ùå Error loading model: {e}")
            return False
