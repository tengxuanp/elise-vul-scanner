"""
Canonical Exploit Routes - /api/exploit
Implements the standardized exploitation endpoint contract
"""

from fastapi import APIRouter, HTTPException
from typing import List, Dict, Any
import logging

# Import exploitation modules
try:
    from modules.ml.exploitation_engine import exploitation_engine
    from modules.real_fuzzer import RealHTTPFuzzer
    EXPLOIT_AVAILABLE = True
except ImportError as e:
    logging.error(f"Failed to import exploitation modules: {e}")
    EXPLOIT_AVAILABLE = False

logger = logging.getLogger(__name__)
router = APIRouter(tags=["exploit"])

@router.post("/exploit")
async def exploit_endpoint(request: Dict[str, Any]) -> Dict[str, Any]:
    """
    Canonical exploit endpoint that attempts to confirm a vulnerability through exploitation.
    
    Request body: Single fuzz result from /api/fuzz
    
    Response: Same structure as fuzz result + "confirmed": bool
    """
    try:
        if not EXPLOIT_AVAILABLE:
            raise HTTPException(500, {
                "error": "ExploitUnavailable",
                "detail": "Exploitation engine not available. Check dependencies."
            })
        
        if not exploitation_engine or not RealHTTPFuzzer:
            raise HTTPException(500, {
                "error": "ExploitEngineUnavailable",
                "detail": "Exploitation engine not initialized"
            })
        
        logger.info(f"🎯 Starting canonical exploitation")
        
        # Extract endpoint and payload from fuzz result
        endpoint = request.get("endpoint", {})
        payload = request.get("payload", "")
        family = request.get("family", "none")
        
        if not endpoint or not payload:
            raise HTTPException(400, "endpoint and payload are required")
        
        # Create exploitation request
        exploit_request = {
            "endpoint": endpoint,
            "original_payload": payload,
            "error_response": "",  # We don't have the original error response
            "max_attempts": 3
        }
        
        # Run exploitation
        exploitation_result = exploitation_engine.exploit_vulnerability(
            endpoint,
            payload,
            ""
        )
        
        # Generate exploitation payloads
        exploitation_payloads = exploitation_engine.generate_exploitation_payloads(
            exploitation_result.error_analysis,
            payload,
            endpoint
        )
        
        # Execute exploitation attempts
        fuzzer = RealHTTPFuzzer()
        confirmed = False
        working_payload = payload
        
        # Try up to 3 exploitation payloads
        for i, payload_info in enumerate(exploitation_payloads[:3]):
            exploit_payload = payload_info["payload"]
            
            try:
                # Fuzz with exploitation payload
                result = fuzzer.fuzz_endpoint(endpoint, exploit_payload)
                
                # Check if exploitation was successful
                if _is_sensitive_data_extraction(result.response_body):
                    confirmed = True
                    working_payload = exploit_payload
                    logger.info(f"✅ Exploitation confirmed with payload: {exploit_payload[:50]}...")
                    break
                    
            except Exception as e:
                logger.debug(f"⚠️ Exploitation attempt {i+1} failed: {e}")
                continue
        
        # Return the original fuzz result with confirmation status
        result = dict(request)  # Copy original request
        result["confirmed"] = confirmed
        result["working_payload"] = working_payload if confirmed else payload
        
        logger.info(f"✅ Canonical exploitation completed: {'CONFIRMED' if confirmed else 'NOT CONFIRMED'}")
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"❌ Canonical exploitation failed: {e}")
        raise HTTPException(500, f"Exploitation failed: {str(e)}")

def _is_sensitive_data_extraction(response_body: str) -> bool:
    """Check if response contains sensitive data (not just normal business data)"""
    if not response_body:
        return False
    
    response_text = response_body.lower()
    
    # Check for SENSITIVE data leakage patterns (not just any data)
    sensitive_data_leakage = [
        '"email":', '"password":', '"user_id":', '"admin"',
        # Look for email patterns in name field (user data leakage)
        '@juice-sh.op', '@owasp.org', 'admin@', 'user@'
    ]
    
    # Check for password hash patterns (32+ character hex strings)
    import re
    password_hash_pattern = r'"[a-f0-9]{32,}"'
    
    # Check for business data patterns that should NOT be flagged
    business_data_patterns = [
        'apple juice', 'orange juice', 'eggfruit juice', 'raspberry juice',
        'lemon juice', 'banana juice', 't-shirt', 'mug', 'hoodie',
        'sticker', 'magnets', 'iron-ons', 'temporary tattoos'
    ]
    
    # Only flag as vulnerable if we see actual sensitive data AND not business data
    has_sensitive_data = (any(pattern in response_text for pattern in sensitive_data_leakage) or
                        re.search(password_hash_pattern, response_text))
    
    has_business_data = any(pattern in response_text for pattern in business_data_patterns)
    
    return has_sensitive_data and not has_business_data

