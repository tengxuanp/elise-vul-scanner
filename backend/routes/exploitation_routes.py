"""
Exploitation API Routes
Handles ML-driven vulnerability exploitation
"""

import logging
import re
from fastapi import APIRouter, HTTPException
from pydantic import BaseModel
from typing import List, Dict, Any, Optional

# Import the exploitation engine
try:
    from modules.ml.exploitation_engine import exploitation_engine
    from modules.real_fuzzer import RealHTTPFuzzer
except ImportError as e:
    logging.error(f"Failed to import exploitation modules: {e}")
    exploitation_engine = None
    RealHTTPFuzzer = None

logger = logging.getLogger(__name__)

router = APIRouter()

class ExploitRequest(BaseModel):
    """Request model for exploitation"""
    endpoint: Dict[str, Any]
    original_payload: str
    error_response: str
    max_attempts: int = 5

class ExploitResult(BaseModel):
    """Result model for exploitation"""
    success: bool
    extracted_data: Optional[str]
    working_payload: Optional[str]
    exploitation_type: str
    confidence: float
    error_analysis: Dict[str, Any]
    suggestions: List[str]
    attempts: List[Dict[str, Any]]

def _is_sensitive_data_extraction(response_body: str) -> bool:
    """Check if response contains sensitive data (not just normal business data)"""
    if not response_body:
        return False
    
    response_text = response_body.lower()
    
    # Check for SENSITIVE data leakage patterns (not just any data)
    sensitive_data_leakage = [
        '"email":', '"password":', '"user_id":', '"admin"',
        # Look for email patterns in name field (user data leakage)
        '@juice-sh.op', '@owasp.org', 'admin@', 'user@'
    ]
    
    # Check for password hash patterns (32+ character hex strings)
    password_hash_pattern = r'"[a-f0-9]{32,}"'
    
    # Check for business data patterns that should NOT be flagged
    business_data_patterns = [
        'apple juice', 'orange juice', 'eggfruit juice', 'raspberry juice',
        'lemon juice', 'banana juice', 't-shirt', 'mug', 'hoodie',
        'sticker', 'magnets', 'iron-ons', 'temporary tattoos'
    ]
    
    # Only flag as vulnerable if we see actual sensitive data AND not business data
    has_sensitive_data = (any(pattern in response_text for pattern in sensitive_data_leakage) or
                        re.search(password_hash_pattern, response_text))
    
    has_business_data = any(pattern in response_text for pattern in business_data_patterns)
    
    return has_sensitive_data and not has_business_data

@router.post("/exploit", response_model=ExploitResult)
async def exploit_vulnerability(request: ExploitRequest):
    """Exploit a detected vulnerability using ML-driven payload generation"""
    
    if not exploitation_engine or not RealHTTPFuzzer:
        raise HTTPException(status_code=500, detail="Exploitation engine not available")
    
    try:
        logger.info(f"üéØ Starting exploitation for {request.endpoint.get('url', '')}")
        
        # Analyze the error and generate exploitation plan
        exploitation_result = exploitation_engine.exploit_vulnerability(
            request.endpoint,
            request.original_payload,
            request.error_response
        )
        
        # Generate exploitation payloads
        exploitation_payloads = exploitation_engine.generate_exploitation_payloads(
            exploitation_result.error_analysis,
            request.original_payload,
            request.endpoint
        )
        
        logger.info(f"üß¨ Generated {len(exploitation_payloads)} exploitation payloads")
        
        # Execute exploitation attempts
        fuzzer = RealHTTPFuzzer()
        attempts = []
        successful_payload = None
        extracted_data = None
        
        # Try up to max_attempts payloads
        for i, payload_info in enumerate(exploitation_payloads[:request.max_attempts]):
            payload = payload_info["payload"]
            
            logger.info(f"üî¨ Attempt {i+1}: {payload[:50]}...")
            
            try:
                # Fuzz with exploitation payload
                result = fuzzer.fuzz_endpoint(request.endpoint, payload)
                
                # Determine if this attempt was successful using improved SQLi detection logic
                is_successful = _is_sensitive_data_extraction(result.response_body)
                
                attempt_result = {
                    "attempt": i + 1,
                    "payload": payload,
                    "description": payload_info["description"],
                    "expected_result": payload_info["expected_result"],
                    "response_status": result.response_status,
                    "response_time": result.response_time,
                    "success": is_successful,
                    "response_preview": result.response_body[:500] if result.response_body else "",
                    "evidence": result.detection_evidence
                }
                
                attempts.append(attempt_result)
                
                # Check if this attempt was successful
                if is_successful:
                    successful_payload = payload
                    extracted_data = result.response_body
                    
                    logger.info(f"‚úÖ Exploitation successful with payload: {payload[:50]}...")
                    break
                    
            except Exception as e:
                logger.error(f"‚ùå Exploitation attempt {i+1} failed: {e}")
                attempts.append({
                    "attempt": i + 1,
                    "payload": payload,
                    "description": payload_info["description"],
                    "expected_result": payload_info["expected_result"],
                    "response_status": 0,
                    "response_time": 0.0,
                    "success": False,
                    "response_preview": f"Error: {str(e)}",
                    "evidence": []
                })
        
        # Update exploitation result with execution results
        exploitation_result.success = successful_payload is not None
        exploitation_result.working_payload = successful_payload
        exploitation_result.extracted_data = extracted_data
        
        logger.info(f"üéØ Exploitation completed: {'SUCCESS' if exploitation_result.success else 'FAILED'}")
        
        return ExploitResult(
            success=exploitation_result.success,
            extracted_data=exploitation_result.extracted_data,
            working_payload=exploitation_result.working_payload,
            exploitation_type=exploitation_result.exploitation_type,
            confidence=exploitation_result.confidence,
            error_analysis=exploitation_result.error_analysis,
            suggestions=exploitation_result.suggestions,
            attempts=attempts
        )
        
    except Exception as e:
        logger.error(f"‚ùå Exploitation failed: {e}")
        raise HTTPException(status_code=500, detail=f"Exploitation failed: {str(e)}")

@router.get("/exploit/status")
async def get_exploitation_status():
    """Get exploitation engine status"""
    return {
        "status": "available" if exploitation_engine else "unavailable",
        "engine_loaded": exploitation_engine is not None,
        "fuzzer_loaded": RealHTTPFuzzer is not None
    }
