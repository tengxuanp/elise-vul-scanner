<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frontend ML Flow Debug</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .debug-section { margin: 20px 0; padding: 15px; border: 1px solid #ccc; border-radius: 5px; }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .failure { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        .code { background-color: #f8f9fa; padding: 10px; border-radius: 3px; font-family: monospace; white-space: pre-wrap; }
        .step { background-color: #fff3cd; border-color: #ffeaa7; margin: 10px 0; padding: 10px; }
    </style>
</head>
<body>
    <h1>Frontend ML Flow Debug</h1>
    <p>Debugging the exact data flow to see where ML detection fails.</p>
    
    <div id="debug-results"></div>

    <script>
        // Copy of the key functions from CrawlAndFuzzPage.jsx
        const hasNum = (v) => typeof v === "number" && isFinite(v);
        const isNonEmptyObj = (o) => !!o && typeof o === "object" && Object.keys(o).length > 0;

        const isMLUsedPath = (usedPath = "") => {
            const parts = Array.isArray(usedPath) ? usedPath : [usedPath];
            const s = parts.map((x) => String(x || "").toLowerCase()).join("|");
            if (!s) return false;
            if (/\b(heuristic|none)\b/.test(s)) return false;
            // Check for enhanced_ml and ml:family patterns (e.g., enhanced_ml, ml:sqli, ml:xss)
            if (/enhanced_ml/.test(s) || /ml:[a-z]+/.test(s)) return true;
            return /(family[-_ ]?ranker|family[-_ ]?router|ml[-_ ]?ranker|ml[-_ ]?router|generic[-_ ]?ranker|plugin|ranker|router)/.test(s);
        };

        function deriveOrigin(one = {}) {
            console.log("üîç deriveOrigin called with:", one);
            
            // Prefer explicit used_path from backend if present
            const usedPath =
                one?.ranker_meta?.used_path ||
                one?.ranker_meta?.ranker?.used_path ||
                one?.ml?.used_path ||
                one?.used_path ||
                null;
            
            console.log("üîç usedPath extracted:", usedPath);
            
            if (usedPath) {
                const isML = isMLUsedPath(usedPath);
                console.log("üîç isMLUsedPath result:", isML);
                if (isML) return "ml";
                if (String(usedPath).toLowerCase() === "heuristic" || String(usedPath).toLowerCase() === "none") return "curated";
            }

            // Simple flags
            if (one.is_ml === true || one.ml === true || one?.payload?.ml === true) {
                console.log("üîç Simple ML flags detected");
                return "ml";
            }

            // Nested ML object hints
            if (one && typeof one === "object" && one.ml && typeof one.ml === "object") {
                const s = String(one.ml.source || one.ml.origin || one.ml.provenance || "").trim().toLowerCase();
                if (/(^|[^a-z])ml([^a-z]|$)/.test(s) || /(ranker|model|ai)/.test(s)) {
                    console.log("üîç Nested ML object hints detected");
                    return "ml";
                }
                if (one.ml.enabled === true || hasNum(one.ml.p) || hasNum(one.ml.score)) {
                    console.log("üîç ML enabled/score detected");
                    return "ml";
                }
                if (isNonEmptyObj(one.ml.ranker_meta || one.ml.ranker)) {
                    console.log("üîç ML ranker_meta detected");
                    return "ml";
                }
            }

            // Explicit string-ish fields if present
            const candidates = [
                one.payload_origin,one.payloadOrigin,one.payload_source,one.payloadSource,
                one.ranker_origin,one.origin,one.source,one.provenance,one.generator,one.kind,one.payload_kind,
                one?.meta?.origin,one?.meta?.source,one?.payload_meta?.origin,one?.payload_meta?.source,
                one?.payload?.origin,one?.payload?.source,
            ].map((v) => (v == null ? "" : String(v).trim().toLowerCase())).filter(Boolean);

            for (const v of candidates) {
                if (/(^|[^a-z])ml([^a-z]|$)/.test(v) || /(ranker|model|ai)/.test(v)) {
                    console.log("üîç ML detected in candidates:", v);
                    return "ml";
                }
                if (/(curated|manual|baseline|core|hand|seed)/.test(v)) {
                    console.log("üîç Curated detected in candidates:", v);
                    return "curated";
                }
            }

            // Heuristics: presence of ranker metadata implies ML
            const rm =
                one.ranker_meta ||
                one.ranker ||
                one.ml_meta ||
                (one.ml && (one.ml.ranker_meta || one.ml.ranker)) ||
                {};
            
            console.log("üîç Ranker metadata object:", rm);
            
            const probs =
                rm.family_probs ||
                rm.probs ||
                rm.family_probabilities ||
                rm.probabilities;

            // NEW: treat array **or object** model_ids as ML
            const hasModelIds =
                !!rm.model_ids &&
                ((Array.isArray(rm.model_ids) && rm.model_ids.length > 0) ||
                 (rm.model_ids && typeof rm.model_ids === "object" && Object.keys(rm.model_ids).length > 0));

            console.log("üîç hasModelIds:", hasModelIds, "model_ids:", rm.model_ids);

            if (
                (isNonEmptyObj(rm) &&
                  (hasNum(rm.ranker_score) || isNonEmptyObj(probs) || hasModelIds)) ||
                hasNum(one.ranker_score) ||
                isNonEmptyObj(one.ranker_probs) ||
                isNonEmptyObj(one.ml_probs)
            ) {
                console.log("üîç ML detected via ranker metadata");
                return "ml";
            }

            // Payload id prefix sometimes encodes provenance
            if (typeof one.payload_id === "string" && /^ml[-_]/i.test(one.payload_id)) {
                console.log("üîç ML detected via payload_id prefix");
                return "ml";
            }

            // Default: assume curated
            console.log("üîç Defaulting to curated");
            return "curated";
        }

        // Test with actual backend data structure from logs
        const backendData = {
            ranker_meta: {
                used_path: "enhanced_ml",
                enhanced: true,
                is_ml_prediction: true,
                confidence: 0.04600627001586819,
                uncertainty: 0.3825205330141813,
                ranker_score: 0.07450655847787857,
                family_probs: { sqli: 1.0 },
                model_ids: { ranker_path: "enhanced_sqli_xgboost", enhanced_ml: true }
            }
        };

        // Test the data flow step by step
        function debugDataFlow() {
            const resultsDiv = document.getElementById('debug-results');
            let html = '';

            // Step 1: Test isMLUsedPath
            html += '<div class="debug-section info">';
            html += '<h3>Step 1: Testing isMLUsedPath Function</h3>';
            const usedPath = backendData.ranker_meta.used_path;
            const isMLPath = isMLUsedPath(usedPath);
            html += `<p><strong>used_path:</strong> <code>${usedPath}</code></p>`;
            html += `<p><strong>isMLUsedPath result:</strong> ${isMLPath ? '‚úÖ TRUE' : '‚ùå FALSE'}</p>`;
            html += '</div>';

            // Step 2: Test deriveOrigin
            html += '<div class="debug-section info">';
            html += '<h3>Step 2: Testing deriveOrigin Function</h3>';
            const origin = deriveOrigin(backendData);
            html += `<p><strong>deriveOrigin result:</strong> <code>${origin}</code></p>`;
            html += `<p><strong>Expected:</strong> "ml"</strong></p>`;
            html += `<p><strong>Result:</strong> ${origin === 'ml' ? '‚úÖ PASS' : '‚ùå FAIL'}</p>`;
            html += '</div>';

            // Step 3: Test the actual data structure
            html += '<div class="debug-section info">';
            html += '<h3>Step 3: Data Structure Analysis</h3>';
            html += '<p><strong>Backend Data Structure:</strong></p>';
            html += `<div class="code">${JSON.stringify(backendData, null, 2)}</div>`;
            
            // Check each field that might affect ML detection
            const rm = backendData.ranker_meta;
            html += '<div class="step">';
            html += '<h4>Field-by-Field Analysis:</h4>';
            html += `<p><strong>used_path:</strong> ${rm.used_path} (type: ${typeof rm.used_path})</p>`;
            html += `<p><strong>enhanced:</strong> ${rm.enhanced} (type: ${typeof rm.enhanced})</p>`;
            html += `<p><strong>is_ml_prediction:</strong> ${rm.is_ml_prediction} (type: ${typeof rm.is_ml_prediction})</p>`;
            html += `<p><strong>confidence:</strong> ${rm.confidence} (type: ${typeof rm.confidence})</p>`;
            html += `<p><strong>ranker_score:</strong> ${rm.ranker_score} (type: ${typeof rm.ranker_score})</p>`;
            html += `<p><strong>family_probs:</strong> ${JSON.stringify(rm.family_probs)} (type: ${typeof rm.family_probs})</p>`;
            html += `<p><strong>model_ids:</strong> ${JSON.stringify(rm.model_ids)} (type: ${typeof rm.model_ids})</p>`;
            html += '</div>';
            html += '</div>';

            // Step 4: Test edge cases
            html += '<div class="debug-section info">';
            html += '<h3>Step 4: Edge Case Testing</h3>';
            
            // Test with different data shapes
            const testCases = [
                {
                    name: "Direct used_path",
                    data: { used_path: "enhanced_ml" }
                },
                {
                    name: "Nested ranker_meta",
                    data: { ranker_meta: { used_path: "enhanced_ml" } }
                },
                {
                    name: "With all ML flags",
                    data: { 
                        ranker_meta: { 
                            used_path: "enhanced_ml",
                            enhanced: true,
                            is_ml_prediction: true
                        }
                    }
                }
            ];

            testCases.forEach((testCase, index) => {
                const testOrigin = deriveOrigin(testCase.data);
                const testIsML = isMLUsedPath(testCase.data.used_path || testCase.data.ranker_meta?.used_path);
                html += `<div class="step">`;
                html += `<h4>Test Case ${index + 1}: ${testCase.name}</h4>`;
                html += `<p><strong>Data:</strong> <code>${JSON.stringify(testCase.data)}</code></p>`;
                html += `<p><strong>isMLUsedPath:</strong> ${testIsML ? '‚úÖ TRUE' : '‚ùå FALSE'}</p>`;
                html += `<p><strong>deriveOrigin:</strong> <code>${testOrigin}</code></p>`;
                html += `<p><strong>Result:</strong> ${testOrigin === 'ml' ? '‚úÖ PASS' : '‚ùå FAIL'}</p>`;
                html += '</div>';
            });

            html += '</div>';

            resultsDiv.innerHTML = html;
        }

        // Run debug when page loads
        window.onload = debugDataFlow;
    </script>
</body>
</html>
